import sys
import os
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))

from flask import Flask, request, jsonify, send_from_directory, url_for
import json
import subprocess
import shutil
import qrcode
import io
import base64
import time # For potential delays

# Import the app generator function
from src.app_generator import generate_app_files

# --- App Initialization ---
_SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
app = Flask(__name__, static_folder="static", static_url_path="")
GENERATED_APPS_DIR = os.path.abspath(os.path.join(_SCRIPT_DIR, "generated_apps"))

# --- GitHub Configuration --- 
# --- IMPORTANT: Load PAT from environment variable --- 
GITHUB_PAT = os.getenv("GITHUB_PAT")
GITHUB_USERNAME = "sandvibe" # User provided username

if not GITHUB_PAT:
    print("Warning: GITHUB_PAT environment variable not set. GitHub integration will likely fail.")

def create_github_repo(repo_name: str) -> bool:
    """Creates a new GitHub repository using GitHub API."""
    if not GITHUB_PAT:
        print("[GitHub Integration] Error: GitHub PAT not set.")
        return False
        
    try:
        # Log creation attempt with specific account
        print(f"[GitHub Integration] Creating repository: {repo_name} for user: {GITHUB_USERNAME}")
        
        # Set up the authorization headers
        headers = {
            "Authorization": f"token {GITHUB_PAT}",
            "Accept": "application/vnd.github.v3+json"
        }
        
        # Repository data
        data = {
            "name": repo_name,
            "description": f"App generated by Vibe Coder - {time.strftime('%Y-%m-%d')}",
            "private": False,
            "auto_init": False,  # Don't initialize with README
            "has_issues": True,
            "has_projects": False,
            "has_wiki": False
        }
        
        # Create repository using GitHub API
        import requests
        # Use the specific endpoint to create the repo
        response = requests.post(f"https://api.github.com/user/repos", headers=headers, json=data)
        
        # Check response
        if response.status_code == 201:
            print(f"[GitHub Integration] Successfully created repository: {repo_name} for user: {GITHUB_USERNAME}")
            print(f"[GitHub Integration] Repository URL: https://github.com/{GITHUB_USERNAME}/{repo_name}")
            return True
        else:
            print(f"[GitHub Integration] Failed to create repository: {repo_name}. Status code: {response.status_code}")
            print(f"[GitHub Integration] Response: {response.text}")
            
            # If there's a 422 error, the repo might already exist
            if response.status_code == 422 and "already exists" in response.text:
                print(f"[GitHub Integration] Repository already exists, will attempt to push anyway.")
                return True
                
            return False
            
    except Exception as e:
        print(f"[GitHub Integration] Error creating repository: {e}")
        return False

def push_to_github_real(app_path: str, app_id: str, app_type: str) -> str:
    """Pushes the generated app code to a new GitHub repository using git commands and PAT."""
    if not GITHUB_PAT:
        print("[GitHub Integration] Error: GitHub PAT not set.")
        return "https://github.com/error/pat-not-set"
        
    repo_name = f"vibe-coded-app-{app_id}"
    repo_url = f"https://github.com/{GITHUB_USERNAME}/{repo_name}"
    git_url = f"{repo_url}.git"
    # Use PAT for authentication in the URL
    authenticated_repo_url = f"https://{GITHUB_USERNAME}:{GITHUB_PAT}@github.com/{GITHUB_USERNAME}/{repo_name}.git"
    commit_message = f"Add {app_type} app ({app_id}) generated by Vibe Coder"

    print(f"[GitHub Integration] Attempting to push code from {app_path} to {repo_url}")
    print(f"[GitHub Integration] Using account: {GITHUB_USERNAME}")
    
    # First create the repository
    repo_created = create_github_repo(repo_name)
    if not repo_created:
        print(f"[GitHub Integration] Warning: Could not create repository {repo_name}. Will attempt to push anyway.")

    try:
        # Check if git is initialized, if so, remove .git dir to avoid nesting issues
        git_dir = os.path.join(app_path, ".git")
        if os.path.exists(git_dir):
            print("[GitHub Integration] Removing existing .git directory.")
            shutil.rmtree(git_dir)
            time.sleep(0.5) # Small delay to ensure directory is removed

        # Initialize git repo
        print("[GitHub Integration] Initializing git repository...")
        subprocess.run(["git", "init"], cwd=app_path, check=True, capture_output=True, text=True)
        
        # Configure git user (temporary for this repo)
        subprocess.run(["git", "config", "user.name", "Vibe Coder Bot"], cwd=app_path, check=True)
        subprocess.run(["git", "config", "user.email", "noreply@vibe.coder"], cwd=app_path, check=True)

        # Add files
        print("[GitHub Integration] Adding files...")
        subprocess.run(["git", "add", "."], cwd=app_path, check=True, capture_output=True, text=True)

        # Commit
        print("[GitHub Integration] Committing files...")
        commit_result = subprocess.run(["git", "commit", "-m", commit_message], cwd=app_path, check=False, capture_output=True, text=True)
        
        if commit_result.returncode != 0:
            if "nothing to commit" in commit_result.stdout.lower() or "nothing to commit" in commit_result.stderr.lower():
                print("[GitHub Integration] Nothing to commit. Adding empty README to force commit.")
                with open(os.path.join(app_path, "README.md"), "a") as f:
                    f.write("\n\nGenerated at: " + time.strftime("%Y-%m-%d %H:%M:%S"))
                subprocess.run(["git", "add", "README.md"], cwd=app_path, check=True, capture_output=True, text=True)
                subprocess.run(["git", "commit", "-m", commit_message], cwd=app_path, check=True, capture_output=True, text=True)
            else:
                print(f"[GitHub Integration] Commit failed: {commit_result.stderr}")
                raise subprocess.CalledProcessError(commit_result.returncode, commit_result.args, stderr=commit_result.stderr)

        # Rename branch to main
        subprocess.run(["git", "branch", "-M", "main"], cwd=app_path, check=True, capture_output=True, text=True)

        # Add remote origin
        print(f"[GitHub Integration] Adding remote origin: {git_url}")
        # Remove existing remote origin if it exists to avoid error
        subprocess.run(["git", "remote", "remove", "origin"], cwd=app_path, check=False, capture_output=True, text=True)
        subprocess.run(["git", "remote", "add", "origin", authenticated_repo_url], cwd=app_path, check=True, capture_output=True, text=True)

        # Push to GitHub
        print("[GitHub Integration] Pushing to GitHub...")
        push_result = subprocess.run(["git", "push", "-u", "origin", "main"], cwd=app_path, check=False, capture_output=True, text=True) # check=False to handle repo not found

        if push_result.returncode != 0:
            if "repository not found" in push_result.stderr.lower():
                print(f"[GitHub Integration] Repository {repo_url} not found. Please verify the GitHub account and token.")
                return f"{repo_url} (Repo not found - please verify account permissions)"
            elif "permission to" in push_result.stderr.lower() and "denied" in push_result.stderr.lower():
                print(f"[GitHub Integration] Permission denied. Please verify the GitHub token has correct permissions.")
                return f"{repo_url} (Permission denied - check token permissions)"
            else:
                print(f"[GitHub Integration] Push failed: {push_result.stderr}")
                raise subprocess.CalledProcessError(push_result.returncode, push_result.args, stderr=push_result.stderr)
        
        print(f"[GitHub Integration] Successfully pushed {app_id} to {repo_url}")
        return repo_url

    except subprocess.CalledProcessError as e:
        print(f"[GitHub Integration] Failed during git operation: {e}")
        print(f"Command: {' '.join(e.cmd)}")
        print(f"Stderr: {e.stderr}")
        return f"{repo_url} (Error: {str(e).split(':', 1)[0]})"
    except FileNotFoundError:
         print("[GitHub Integration] Failed: git command not found. Ensure it is installed and in PATH.")
         return f"{repo_url} (Error: git command not found)"
    except Exception as e:
        print(f"[GitHub Integration] An unexpected error occurred: {e}")
        return f"{repo_url} (Error: {str(e)[:50]})"
    finally:
        # Clean up .git directory after push to prevent issues if run again in same dir
        git_dir = os.path.join(app_path, ".git")
        if os.path.exists(git_dir):
            try:
                shutil.rmtree(git_dir)
                print("[GitHub Integration] Cleaned up .git directory.")
            except Exception as e:
                 print(f"[GitHub Integration] Warning: Failed to clean up .git directory: {e}")

# --- QR Code Generation --- 
def generate_qr_code_base64(url: str) -> str:
    """Generates a QR code for the given URL and returns it as a base64 encoded PNG image."""
    try:
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(url)
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        buffer = io.BytesIO()
        img.save(buffer, format="PNG")
        buffer.seek(0)
        img_base64 = base64.b64encode(buffer.getvalue()).decode("utf-8")
        return img_base64
    except Exception as e:
        print(f"Error generating QR code for {url}: {e}")
        return ""

# --- Routes --- 

@app.route("/")
def index():
    """Serve the main HTML page."""
    return send_from_directory(app.static_folder, "index.html")

@app.route("/generate", methods=["POST"])
def generate_app_route():
    """Handle the app generation request from the frontend."""
    try:
        data = request.get_json()
        if not data or "app_type" not in data or "amount" not in data:
            return jsonify({"error": "Missing app_type or amount in request"}), 400

        app_type = data.get("app_type")
        amount_str = data.get("amount")

        # Validate amount
        try:
            payment_amount = float(amount_str)
            if payment_amount <= 0:
                raise ValueError("Amount must be positive")
        except (ValueError, TypeError):
            return jsonify({"error": "Invalid amount specified"}), 400

        # Call App Generation Logic (Step 004 - Enhanced)
        generated_app_details = generate_app_files(app_type, payment_amount)
        
        if not generated_app_details:
            # Error logged within generate_app_files
            return jsonify({"error": f"Failed to generate app code for type: {app_type}"}), 500

        # Call GitHub Integration (Step 005 - Real)
        github_url = push_to_github_real(
            generated_app_details["path"], 
            generated_app_details["app_id"],
            generated_app_details["app_type"]
        )

        # Web Hosting URL (Step 005 - using local route)
        hosted_url_relative = url_for("serve_generated_app", app_id=generated_app_details["app_id"], _external=False)
        # Construct the full URL using the request host URL
        hosted_url_full = request.host_url.strip("/") + hosted_url_relative

        # Call QR Code Generation (Step 006)
        qr_code_base64 = generate_qr_code_base64(hosted_url_full)

        # Return success response including the full URL
        return jsonify({
            "message": f"App {generated_app_details['app_id']} generated successfully (Tier: {generated_app_details['tier']}).",
            "app_type_received": app_type,
            "amount_received": payment_amount,
            "hosted_url_relative": hosted_url_relative, # Relative URL for links within the page
            "hosted_url_full": hosted_url_full, # Full URL for display and QR code
            "github_url": github_url, 
            "qr_code_image": qr_code_base64,
            "readme_generated": "readme_path" in generated_app_details, # Boolean indicating if README was generated
            "user": "testuser" # Hardcoded user as requested
        }), 200

    except Exception as e:
        print(f"Error during generation route: {e}") # Log error server-side
        return jsonify({"error": f"An internal error occurred: {str(e)}"}), 500

# --- Route to serve generated apps (Part of Step 005) ---
@app.route("/apps/<app_id>/")
def serve_generated_app(app_id):
    """Serve the index.html of a generated app."""
    if not app_id or not all(c.isalnum() or c == "-" for c in app_id):
         return jsonify({"error": "Invalid app ID format"}), 400
         
    app_directory = os.path.abspath(os.path.join(GENERATED_APPS_DIR, app_id))
    if not app_directory.startswith(GENERATED_APPS_DIR):
        return jsonify({"error": "Invalid app path"}), 400
        
    index_path = os.path.join(app_directory, "index.html")
    if not os.path.exists(index_path):
        return jsonify({"error": "App not found"}), 404
        
    return send_from_directory(app_directory, "index.html")

# --- Main Execution ---
if __name__ == "__main__":
    # Use port 5002 for local testing
    port = int(os.getenv("PORT", 5002))
    # Set debug=True for development
    app.run(debug=True, host="0.0.0.0", port=port) 